<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Netty框架：echo服务器 | /home/zenuo</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Netty框架：echo服务器" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Netty客户端/服务器概览" />
<meta property="og:description" content="Netty客户端/服务器概览" />
<link rel="canonical" href="https://zenuo.github.io/2018/01/22/Netty%E6%A1%86%E6%9E%B6-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8.html" />
<meta property="og:url" content="https://zenuo.github.io/2018/01/22/Netty%E6%A1%86%E6%9E%B6-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8.html" />
<meta property="og:site_name" content="/home/zenuo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Netty框架：echo服务器" />
<script type="application/ld+json">
{"description":"Netty客户端/服务器概览","url":"https://zenuo.github.io/2018/01/22/Netty%E6%A1%86%E6%9E%B6-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8.html","@type":"BlogPosting","headline":"Netty框架：echo服务器","dateModified":"2018-01-22T00:00:00+00:00","datePublished":"2018-01-22T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zenuo.github.io/2018/01/22/Netty%E6%A1%86%E6%9E%B6-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://zenuo.github.io/feed.xml" title="/home/zenuo" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">/home/zenuo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Netty框架：echo服务器</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-01-22T00:00:00+00:00" itemprop="datePublished">Jan 22, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="netty客户端服务器概览">Netty客户端/服务器概览</h2>

<p>图2-1从<strong>高层次</strong>上展示了一个将要编写的Echo客户端和服务器应用程序。虽然你的主要关注点可能是编写基于Web的用于被浏览器访问的应用程序，但是通过同时实现客户端和服务器，你一定能更加全面地理解Netty的API。</p>

<p><img src="/assets/img/2ba43fa2529d62a6829b351f.png" alt="2ba43fa2529d62a6829b351f.png" /></p>

<p>图2-1　Echo客户端和服务器</p>

<p>虽然我们已经谈及到了客户端，但是该图展示的是多个客户端<strong>同时</strong>连接到一台服务器。所能够支持的客户端数量，在理论上，仅受限于系统的<strong>可用资源</strong>（以及所使用的JDK版本<strong>可能</strong>会施加的限制）。</p>

<p>Echo客户端和服务器之间的交互是非常简单的；在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。虽然它本身看起来好像用处不大，但它充分地体现了客户端/服务器系统中典型的请求-响应交互模式。</p>

<p>我们将从考察服务器端代码开始这个项目。</p>

<h2 id="编写echo服务器">编写Echo服务器</h2>

<p>所有的Netty服务器都需要以下两部分。</p>

<ol>
  <li>至少一个ChannelHandler——该组件实现了服务器对从客户端接收的数据的处理，即它的业务逻辑。</li>
  <li>引导——这是配置服务器的启动代码。至少，它会将服务器绑定到它要监听连接请求的端口上。</li>
</ol>

<p>在本小节的剩下部分，我们将描述Echo服务器的业务逻辑以及引导代码。</p>

<h3 id="channelhandler和业务逻辑channelhandlers-and-business-logic">ChannelHandler和业务逻辑（ChannelHandlers and business logic）</h3>

<p>我们已经讨论了<strong>Future</strong>和<strong>回调</strong>，并且阐述了它们在<strong>事件驱动设计</strong>中的应用。我们还讨论了<strong><code class="language-plaintext highlighter-rouge">ChannelHandler</code></strong>，它是一个接口族的<strong>父接口</strong>，它的实现负责<strong>接收并响应</strong>事件通知。在Netty应用程序中，所有的数据处理逻辑都包含在这些核心抽象的实现中。</p>

<p>因为你的Echo服务器会响应传入的消息，所以它需要实现<strong><code class="language-plaintext highlighter-rouge">ChannelInboundHandler</code></strong>接口，用来定义<strong>响应入站事件的方法</strong>。这个简单的应用程序只需要用到少量的这些方法，所以继承<strong><code class="language-plaintext highlighter-rouge">ChannelInboundHandlerAdapter</code></strong>类也就足够了，它提供了<strong><code class="language-plaintext highlighter-rouge">ChannelInboundHandler</code></strong>的默认实现。</p>

<p>我们感兴趣的方法是：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">channelRead()</code></strong>——对于每个传入的消息都要调用；</li>
  <li><strong><code class="language-plaintext highlighter-rouge">channelReadComplete()</code></strong>——通知ChannelInboundHandler最后一次对channel-Read()的调用是当前批量读取中的最后一条消息；</li>
  <li><strong><code class="language-plaintext highlighter-rouge">exceptionCaught()</code></strong>——在读取操作期间，有异常抛出时会调用。</li>
</ul>

<p>该Echo服务器的ChannelHandler实现是EchoServerHandler，如代码清单2-1所示。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 代码清单2-1　EchoServerHandler</span>
<span class="nd">@Sharable</span>  <span class="c1">// 标示一个Channel- Handler可以被多个Channel安全地共享</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoServerHandler</span> <span class="kd">extends</span> <span class="nc">ChannelInboundHandlerAdapter</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelRead</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ByteBuf</span> <span class="n">in</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ByteBuf</span><span class="o">)</span> <span class="n">msg</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="s">"Server received: "</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>     <span class="c1">// 将消息记录到控制台</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>  <span class="c1">// 将接收到的消息写给发送者，而不冲刷出站消息</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelReadComplete</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">EMPTY_BUFFER</span><span class="o">)</span>
            <span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="nc">ChannelFutureListener</span><span class="o">.</span><span class="na">CLOSE</span><span class="o">);</span>   <span class="c1">// 将未决消息[4]冲刷到远程节点，并且关闭该Channel</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exceptionCaught</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span>
        <span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cause</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>     <span class="c1">// 打印异常栈跟踪</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>   <span class="c1">// 关闭该Channel</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>未决消息（pending message）</strong>指目前暂存于<strong><code class="language-plaintext highlighter-rouge">ChannelOutboundBuffer</code></strong>中的消息，在下一次调用<strong><code class="language-plaintext highlighter-rouge">flush()</code></strong>或者<strong><code class="language-plaintext highlighter-rouge">writeAndFlush()</code></strong>方法时将会尝试写出到套接字。</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">ChannelInboundHandlerAdapter</code></strong>有一个直观的API，并且它的每个方法都可以被重写以挂钩到<strong><code class="language-plaintext highlighter-rouge">事件生命周期</code></strong>的恰当点上。因为需要处理所有接收到的数据，所以你重写了<strong><code class="language-plaintext highlighter-rouge">channelRead()</code></strong>方法。在这个服务器应用程序中，你将数据简单地回送给了远程节点。</p>

<p>重写<strong><code class="language-plaintext highlighter-rouge">exceptionCaught()</code></strong>方法允许你对<strong><code class="language-plaintext highlighter-rouge">Throwable</code></strong>的任何子类型做出反应，在这里你记录了异常并关闭了连接。虽然一个更加完善的应用程序也许会尝试从异常中恢复，但在这个场景下，只是通过简单地关闭连接来通知远程节点发生了错误。</p>

<blockquote>
  <p><strong>如果不捕获异常，会发生什么呢？</strong></p>
</blockquote>

<blockquote>
  <p>每个Channel都拥有一个与之相关联的<strong><code class="language-plaintext highlighter-rouge">ChannelPipeline</code></strong>，其持有一个ChannelHandler的实例链。在默认的情况下，ChannelHandler会把对它的方法的调用转发给链中的下一个ChannelHandler。因此，如果exceptionCaught()方法没有被该链中的某处实现，那么所接收的异常将会被传递到ChannelPipeline的<strong>尾端</strong>并被记录。为此，你的应用程序应该提供<strong>至少有一个</strong>实现了exceptionCaught()方法的ChannelHandler。</p>
</blockquote>

<p>除了ChannelInboundHandlerAdapter之外，还有很多需要学习的ChannelHandler的子类型和实现。目前，请记住下面这些关键点：</p>

<ul>
  <li>针对不同类型的事件来调用ChannelHandler；</li>
  <li>应用程序通过实现或者扩展ChannelHandler来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑；</li>
  <li>在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的<strong>分离</strong>。这简化了开发过程，因为代码必须不断地演化以响应<strong>不断变化的需求</strong>。</li>
</ul>

<h3 id="引导服务器bootstrapping-the-server">引导服务器（Bootstrapping the server）</h3>

<p>在讨论过由EchoServerHandler实现的核心业务逻辑之后，我们现在可以探讨引导服务器本身的过程了，具体涉及以下内容：</p>

<ul>
  <li>绑定到服务器将在其上监听并接受传入连接请求的端口；</li>
  <li>配置Channel，以将有关的入站消息通知给EchoServerHandler实例。</li>
</ul>

<blockquote>
  <p><strong>传输层（Transports）</strong></p>
</blockquote>

<blockquote>
  <p>在网络协议的标准多层视图中，传输层提供了端到端的或者主机到主机的通信服务。因特网通信是建立在TCP传输之上的。除了一些由Java NIO实现提供的服务器端性能增强之外，NIO传输大多数时候指的就是TCP传输。</p>
</blockquote>

<p>代码清单2-2展示了EchoServer类的完整代码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 代码清单2-2　EchoServer类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoServer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">EchoServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                <span class="s">"Usage: "</span> <span class="o">+</span> <span class="nc">EchoServer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">()</span> <span class="o">+</span>
                <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>   <span class="c1">// 设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span>
        <span class="k">new</span> <span class="nf">EchoServer</span><span class="o">(</span><span class="n">port</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>   <span class="c1">// 调用服务器的start()方法</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">EchoServerHandler</span> <span class="n">serverHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EchoServerHandler</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">group</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>   <span class="c1">// ❶ 创建Event-LoopGroup</span>
        <span class="k">try</span> <span class="o">{</span>
             <span class="nc">ServerBootstrap</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">();</span>   <span class="c1">//  ❷ 创建Server-Bootstrap</span>
             <span class="n">b</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">group</span><span class="o">)</span>
                 <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>   <span class="c1">// ❸ 指定所使用的NIO传输Channel</span>
                 <span class="o">.</span><span class="na">localAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">port</span><span class="o">))</span>   <span class="c1">// ❹ 使用指定的端口设置套接字地址</span>
                <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ChannelInitializer</span><span class="o">(){</span>   <span class="c1">// ❺添加一个EchoServer-</span>
<span class="nc">Handler到子Channel的ChannelPipeline</span>
                 <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">ch</span><span class="o">)</span>
                    <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
                         <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="n">serverHandler</span><span class="o">);[</span><span class="mi">5</span><span class="o">]</span>   <span class="c1">// EchoServerHandler被标注为@Shareable，所以我们可以总是使用同样的实例</span>
                    <span class="o">}</span>
                 <span class="o">});</span>
            <span class="nc">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">bind</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>   <span class="c1">// ❻ 异步地绑定服务器；调用sync()方法阻塞等待直到绑定完成</span>
            <span class="n">f</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">closeFuture</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>   <span class="c1">// ❼ 获取Channel的CloseFuture，并且阻塞当前线程直到它完成</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">group</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>   <span class="c1">//  ❽ 关闭EventLoopGroup，释放所有的资源</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在➋处，你创建了一个<strong><code class="language-plaintext highlighter-rouge">ServerBootstrap</code></strong>实例。因为你正在使用的是<strong><code class="language-plaintext highlighter-rouge">NIO</code></strong>传输，所以你指定了<strong><code class="language-plaintext highlighter-rouge">NioEventLoopGroup</code></strong>➊来接受和处理新的连接，并且将Channel的类型指定为<strong><code class="language-plaintext highlighter-rouge">NioServerSocketChannel</code></strong>➌。在此之后，你将本地地址设置为一个具有选定端口的<strong><code class="language-plaintext highlighter-rouge">InetSocketAddress</code></strong>➍。服务器将绑定到这个地址以监听新的连接请求。</p>

<p>在➎处，你使用了一个特殊的类——<strong><code class="language-plaintext highlighter-rouge">ChannelInitializer</code></strong>。这是关键。当一个<strong>新的连接</strong>被接受时，一个新的<strong>子Channel</strong>将会被创建，而ChannelInitializer将会把一个你的<strong><code class="language-plaintext highlighter-rouge">EchoServerHandler</code></strong>的实例添加到该Channel的<strong><code class="language-plaintext highlighter-rouge">ChannelPipeline</code></strong>中。正如我们之前所解释的，这个ChannelHandler将会收到有关<strong>入站消息</strong>的通知。</p>

<p>虽然NIO是<strong>可伸缩</strong>的，但是其适当的尤其是关于<strong>多线程处理的配置</strong>并不简单。Netty的设计封装了大部分的复杂性。</p>

<p>接下来你绑定了服务器➏，并<strong>等待</strong>绑定完成。（对<strong><code class="language-plaintext highlighter-rouge">sync()</code></strong>方法的调用将导致当前Thread<strong><code class="language-plaintext highlighter-rouge">阻塞</code></strong>，一直到绑定操作完成为止）。在➐处，该应用程序将会阻塞等待直到服务器的Channel关闭（因为你在Channel的<strong><code class="language-plaintext highlighter-rouge">Close Future</code></strong>上调用了sync()方法）。然后，你将可以关闭<strong><code class="language-plaintext highlighter-rouge">EventLoopGroup</code></strong>，并释放所有的资源，包括所有被创建的线程➑。</p>

<p>这个示例使用了NIO，因为得益于<strong>它的可扩展性和彻底的异步性</strong>，它是目前使用最广泛的传输。但是也可以使用一个不同的传输实现。如果你想要在自己的服务器中使用OIO传输，将需要指定<strong><code class="language-plaintext highlighter-rouge">OioServerSocketChannel</code></strong>和<strong><code class="language-plaintext highlighter-rouge">OioEventLoopGroup</code></strong>。</p>

<p>与此同时，让我们回顾一下你刚完成的服务器实现中的重要步骤。下面这些是服务器的主要代码组件：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">EchoServerHandler</code></strong>实现了业务逻辑</li>
  <li><strong><code class="language-plaintext highlighter-rouge">main()</code></strong>方法<strong><code class="language-plaintext highlighter-rouge">引导</code></strong>了服务器</li>
</ul>

<p>引导过程中所需要的步骤如下：</p>

<ul>
  <li>创建一个<strong><code class="language-plaintext highlighter-rouge">ServerBootstrap</code></strong>的实例以引导和绑定服务器</li>
  <li>创建并分配一个<strong><code class="language-plaintext highlighter-rouge">NioEventLoopGroup</code></strong>实例以进行事件的处理，如接受新连接以及<strong><code class="language-plaintext highlighter-rouge">读/写</code></strong>数据</li>
  <li>指定服务器绑定的本地的<strong><code class="language-plaintext highlighter-rouge">InetSocketAddress</code></strong></li>
  <li>使用一个<strong><code class="language-plaintext highlighter-rouge">EchoServerHandler</code></strong>的实例初始化每一个新的<strong><code class="language-plaintext highlighter-rouge">Channel</code></strong></li>
  <li>调用<strong><code class="language-plaintext highlighter-rouge">ServerBootstrap.bind()</code></strong>方法以绑定服务器</li>
</ul>

<p>在这个时候，服务器已经初始化，并且已经就绪能被使用了。</p>

  </div><a class="u-url" href="/2018/01/22/Netty%E6%A1%86%E6%9E%B6-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">/home/zenuo</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">/home/zenuo</li><li><a class="u-email" href="mailto:zenuo@protonmail.com">zenuo@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/zenuo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">zenuo</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>The quieter you become, the more you are able to hear.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
